
Effective C++의 각 항목 별 이것만은 잊지 말자! 요약 정리본

1.	C++를 사용한 효과적인 프로그래밍 규칙은 경우에 따라 달라집니다.
	그 경우란. 바로 C++의 어떤 부분을 사용하느냐 입니다.

2.	단순 상수를 쓸때는, #define보다 const객체 혹은 enum을 우선 생각한다.
	함수처럼 쓰이는 매크로를 만들려면, #define매크로보다 인라인 함수를 우선 생각한다.

3.	const를 붙여 선언하면 컴파일러가 사용상의 에러를 잡아내는 데 도움을 줍니다.
	const는 어떤 유효범위에 있는 객체에도 붙을 수 있으며, 함수 매게변수 및 변환 타입에도 붙을 수 있고 멤버 함수에도 붙을 수 있습니다.
	컴파일러 쪽에서 보면 비트수준 상수성을 지켜야 하지만, 여러분은 개념적인(논리적인) 상수성을 사용해서 프로그래밍 해야합니다.
	상수 멤버 및 비상수 멤버함수가 기능적으로 서로 똑같게 구현되어 있을 경우에는 코드 중복을 피하는 것이 좋은데, 이때 비상수 버전을 호출하도록 만드세요.

4.	기본제공 타입의 객체는 직접 손으로 초기화합니다.
	경우에 따라 저절로 되기도 하고 안되기도 하기 때문입니다.
	생성자에서는 데이터 멤버에 대한 대입문을 생성자 본문 내부에 넣는 방법으로 멤버를 초기화 하지 말고 멤버 초기화 리스트를 즐겨 사용합시다.
	그리고 초기화리스트에 데이터 멤버를 나열한 때는 클라스에 각 데이터 멤버가 선언된 순서와 똑같이 나열합시다.
	여러 번역 단위에 있는 비지역 정적 객체들의 초기화 순서 문제는 피해서 설계해야 합니다.
	비지역  정적 객체들 지역 정적 객체로 바꾸면 됩니다.

5.	컴파일러는 경우에 따라 클래스에 대해 기본 생성자, 복사 생성자, 복사 대입 연산자, 소멸자를 암시적으로 만들어 놓을 수 있습니다.

6.	컴파일러에서 자동으로 제공하는 기능은 허용치 않으려면, 대용되는 멤버함수를 private로 선언한 후에 구현은 하지 않은 채로 두십시오.
	Uncopyable과 비슷한 기본 클래스를 쓰는 것도 한 방법입니다.

7.	다향성을 가진 기본 클래스에는 반드시 가상 소멸자를 선언해야 합니다.
	즉, 어떤 클래스가 가상 함수를 하나라도 갖고 있으면, 이 클래스의 소멸자도 가상 소멸자이어야 합니다.
	기본 클래스로 설게되지 않았거나 다형성을 갖도록 설계되지 않은 클래스에는 가상 소멸자를 선언하지 말아야 합니다.

8.	소멸자에서는 예외가 빠져나가면 안됩니다.
	만약 소멸자 안에서 호출된 함수가 예외를 던질 가능성이 있다면, 어떤 예외이던지 소멸자에서 모두 받아낸 후에 삼켜 버리든지 프로그램을 끝내던지 해야합니다.
	어떤 클래스의 연산이 진행되다가 던진 예외에 대해 사용자가 반응해야 할 필요가 있다면, 해당 연산을 제공하는 함수가 반드시 보통의 함수(즉, 소멸자가 아닌 함수)이어야 합니다.

9.	생성자 혹은 소멸자안에서 가상 함수를 호출하지 마세요.
	가상함수라고 해도, 지금 실행중인 생성자나 소멸자에 해당되는 클래스의 파생 클래스 쪽으로는 내려가지 않는다.

10.	대입 연산자는 *this의 참조자를 반환하도록 만드세요.

11.	operator=을 구현할 때, 어떤 객체가 그 자신에 대입되는 경우를 제대로 처리하도록 만듭시다. 
	원본 객체와 복사 대상 객체의 주소를 비교해도 되고, 문장의 순서를 적절히 조정할 수도 있으며, 복사 후 맞바꾸기 기법을 써도 됩니다.
	두개 이상의 객체에 대해 동작하는 함수가 있다면, 이 함수에 넘겨지는 객체들이 사실 같은 객체인 경우에 정확하게 동작하는지 확인해 보세요.

12.	객체복사 함수는 주어진 객체의 모든 데이터멤버 및 모든 기본 클래스 부분을 빠뜨리지 말고 복사해야 합니다.
	클래스의 사함수 두개를 구현할 때, 한 쪽을 이용해서 다른 쪽을 구현하려는 시도는 절대로 하지 마세요. 
	그 대신, 공통된 동작을 제 3의 함수에다 분리해놓고 양쪽에서 이것을 호출하게 만들어서 해결합시다.

13.	자원 누출을 막기 위해, 생성자 안에서 자원을 흭득하고 소멸자에서 그것을 해제 하는 RAII객체를 사용합시다.
	일반적으로 널리 쓰이는 RAII클래스는 tr1::shared_ptr그리고 auto_ptr입니다.
	이 둘 가운데 tr1::shared_ptr이 복사 시의 동작이 직관적이기 때문에 대게 좋습니다.
	반면, auto_ptr은 복사되는 객체(원본 객체)를 null로 만들어 버립니다.

14.	RAII 객체의 복사는 그 객체가 관리하는 자원의 복사 문제를 안고가기 때문에, 그 자원을 어떻게 복사하느냐에 따라 RAII객체의 복사 동작이 결정됩니다.
	RAII 클래스의 구현하는 일반적인 복사 동작은 복사를 금지하거나 참조 카운팅을 해주는 선으로 마무리 하는 것 입니다.
	하지만 이 외의 방법들도 가능하니 참고해 둡시다.

15.	실제 자원을 직접 접근해야 하는 기존 API들도 만기 때문에, RAII클래스를 만들 때는 그 클래스가 관리하는 자원을 얻을 수 있는 방법을 열어 주어야 합니다.
	자원접근은 명시적 변환 혹은 암시적 변환을 통해 가능합니다.
	안전성만 따지면 명시적 변환이 대체적으로 더 낫지만 고객 편의성을 놓고 보면 암시적 변환이 괜찮습니다.

16. new 표현식에 []를 썼으면, 대응되는 delete 표현식에도 []를 써야합니다.
	마찬가지로 new 표현식에 []를 안 썼으면, 대응되는 delete에도 []를 쓰지 말아야 합니다.

17.	new로 생성한 객체를 스마터 포인터로 넣는 코드는 별도의 한 문장으로 만듭시다.
	이것이 안되어 있으면, 예외가 발생될 때 디버깅 하기 힘든 자원누출이 초래될 수 있습니다.

18. 좋은 인터페이스는 제대로 쓰기에 쉬우며 엉터리로 쓰기에 어렵습니다.
	인터페이스를 만들 때는 이 특성을 지닐 수 있도록 고민하고 또 고민합시다.
	인터페이스의 올바른 사용을 이끄는 방법으로는 인터페이스 사이의 일관성을 잡아주기, 그리고 기본제공 타입과의 동작 호환성 유지하기가 있습니다.
	사용자의 실수를 방지하는 방법으로는 새로운 타입 만들기, 타입에 대한 연산을 제한하기, 객체의 값에 대해 제약 걸기, 자원 관리 작업을 사용자 책임으로 놓지 않기가 있습니다.
	tr1::shared_ptr은 사용자 정의 삭제자를 지원합니다. 이 특직 때문에 tr1::shared_ptr은 교차 DLL문제를 막아 주며, 뮤텍스 등을 자동으로 잠금 해제하는 데 쓸 수 있습니다.

19. 클래스 설계는 타입설계 입니다.
	새로운 타입을 정의하기 전에, 이번 항목에 나온 모든 고려사항을 빠짐없이 점검해 보십시오.

20. '값에 의한 전달'보다는 '상수 객체 참조자에 의한 전달'을 선호합시다.
	대체적으로 효율적일 뿐만 아니라 복사손실 문제까지 막아 줍니다.
	이번 항목에서 다룬 법칙은 기본제공 타입 및 STL 반복자, 그리고 함수 객체 타입에는 맞지 않습니다.
	이들에 대해서는 '값에 의한 전달'이 더 적절합니다.

21.